Index: Poke.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import requests\r\nimport random\r\n\r\n# URL de base de l'API PokéAPI\r\nBASE_URL = \"https://pokeapi.co/api/v2/pokemon?limit=100000&offset=0\"\r\nBASE_URL_TYPE = \"https://pokeapi.co/api/v2/type/\"\r\n\r\n\r\n# Fonction pour récupérer tous les Pokémon\r\ndef get_all_pokemon():\r\n    try:\r\n        response = requests.get(BASE_URL)\r\n        if response.status_code == 200:\r\n            data = response.json()\r\n            # Récupérer les Pokémon sous forme de liste (nom et ID)\r\n            return [(pokemon['name'], pokemon['url'].split('/')[-2]) for pokemon in data['results']]\r\n        else:\r\n            print(f\"Erreur lors de la récupération des Pokémon : {response.status_code}\")\r\n            return []\r\n    except Exception as e:\r\n        print(f\"Erreur : {e}\")\r\n        return []\r\n\r\n\r\n# Fonction pour récupérer les détails d'un mouvement\r\ndef get_move_details(move_name):\r\n    try:\r\n        response = requests.get(f\"https://pokeapi.co/api/v2/move/{move_name}\")\r\n        if response.status_code == 200:\r\n            move_data = response.json()\r\n            damage_class = move_data['damage_class']['name'] if move_data.get('damage_class') else 'N/A'\r\n            return {\r\n                'name': move_data['name'],\r\n                'power': move_data.get('power', 'N/A'),  # La puissance peut ne pas être disponible\r\n                'type': move_data['type']['name'],\r\n                'damage_class': damage_class.capitalize()  # Ajout de la classe de dégâts\r\n            }\r\n        else:\r\n            print(f\"Erreur lors de la récupération du mouvement {move_name}: {response.status_code}\")\r\n            return None\r\n    except Exception as e:\r\n        print(f\"Erreur lors de la récupération du mouvement {move_name}: {e}\")\r\n        return None\r\n\r\n\r\n# Fonction pour récupérer les types et leurs effets\r\ndef get_type_effectiveness():\r\n    type_effectiveness = {}\r\n    try:\r\n        response = requests.get(\"https://pokeapi.co/api/v2/type/\")\r\n        if response.status_code == 200:\r\n            data = response.json()\r\n            for type_info in data['results']:\r\n                type_id = type_info['url'].split('/')[-2]\r\n                effectiveness_response = requests.get(f\"{BASE_URL_TYPE}{type_id}/\")\r\n                if effectiveness_response.status_code == 200:\r\n                    effectiveness_data = effectiveness_response.json()\r\n                    # Enregistrer les effets de type\r\n                    type_effectiveness[type_info['name']] = {\r\n                        'double_damage_to': {effect['name']: 2 for effect in effectiveness_data['damage_relations']['double_damage_to']},\r\n                        'half_damage_to': {effect['name']: 0.5 for effect in effectiveness_data['damage_relations']['half_damage_to']},\r\n                        'no_damage_to': {effect['name']: 0 for effect in effectiveness_data['damage_relations']['no_damage_to']},\r\n                    }\r\n    except Exception as e:\r\n        print(f\"Erreur lors de la récupération des types : {e}\")\r\n\r\n    return type_effectiveness\r\n\r\n\r\n# Fonction pour afficher la table des types\r\ndef display_type_table(type_effectiveness):\r\n    print(\"\\nTable des Types de Pokémon et leurs effets :\\n\")\r\n    for poke_type, effects in type_effectiveness.items():\r\n        print(f\"Type: {poke_type.capitalize()}\")\r\n        print(f\"  - Dégâts doublés contre : {', '.join(effects['double_damage_to']).capitalize() or 'Aucun'}\")\r\n        print(f\"  - Dégâts réduits de moitié contre : {', '.join(effects['half_damage_to']).capitalize() or 'Aucun'}\")\r\n        print(f\"  - Aucun dégâts infligé contre : {', '.join(effects['no_damage_to']).capitalize() or 'Aucun'}\")\r\n        print(\"-\" * 50)\r\n\r\n\r\n# Fonction pour récupérer les données d'un Pokémon aléatoire\r\ndef get_random_pokemon(pokemon_list):\r\n    if not pokemon_list:\r\n        return None\r\n\r\n    while True:  # Boucle jusqu'à ce qu'un Pokémon valide soit trouvé\r\n        # Choisir un Pokémon aléatoire\r\n        pokemon_name, pokemon_id = random.choice(pokemon_list)\r\n        # Récupérer les détails du Pokémon\r\n        response = requests.get(f\"https://pokeapi.co/api/v2/pokemon/{pokemon_id}\")\r\n\r\n        if response.status_code == 200:\r\n            data = response.json()\r\n            # Extraire les stats\r\n            stats = {stat['stat']['name']: stat['base_stat'] for stat in data['stats']}\r\n\r\n            # Extraire les mouvements\r\n            moves = [move['move']['name'] for move in data['moves']]\r\n\r\n            # Vérifier si le Pokémon a au moins un mouvement\r\n            if moves:\r\n                # Sélectionner 4 mouvements aléatoires\r\n                selected_moves = random.sample(moves, min(4, len(moves)))  # S'assurer de ne pas dépasser le nombre de mouvements disponibles\r\n\r\n                # Récupérer les détails des mouvements sélectionnés\r\n                moves_details = [get_move_details(move) for move in selected_moves]\r\n\r\n                return {\r\n                    'name': data['name'],\r\n                    'stats': stats,\r\n                    'moves': moves_details  # Stocker les détails des mouvements\r\n                }\r\n            else:\r\n                print(f\"{pokemon_name.capitalize()} n'a pas de mouvements. Récupération d'un autre Pokémon...\")\r\n        else:\r\n            print(f\"Erreur lors de la récupération du Pokémon avec ID {pokemon_id}\")\r\n            return None\r\n\r\n\r\n# Fonction pour récupérer 16 Pokémon uniques avec leurs stats et mouvements\r\ndef get_unique_pokemons_with_details(pokemon_list, count=16):\r\n    unique_pokemons = []  # Liste pour stocker les Pokémon avec leurs détails\r\n\r\n    while len(unique_pokemons) < count:\r\n        random_pokemon = get_random_pokemon(pokemon_list)\r\n        if random_pokemon and random_pokemon not in unique_pokemons:\r\n            unique_pokemons.append(random_pokemon)  # Ajouter le Pokémon avec ses détails\r\n\r\n    return unique_pokemons\r\n\r\n\r\n# Exemple d'utilisation\r\npokemon_list = get_all_pokemon()\r\nunique_pokemons = get_unique_pokemons_with_details(pokemon_list, 16)\r\n\r\nprint(\"Liste des 16 Pokémon récupérés :\")\r\nfor pokemon in unique_pokemons:\r\n    print(f\"\\nPokémon : {pokemon['name'].capitalize()}\")\r\n    print(\"Stats :\")\r\n    for stat_name, stat_value in pokemon['stats'].items():\r\n        print(f\"  - {stat_name.capitalize()}: {stat_value}\")\r\n    print(f\"\\nMoveset {pokemon['name'].capitalize()} :\")\r\n    for move in pokemon['moves']:\r\n        print(\r\n            f\"  - {move['name'].capitalize()} (Type: {move['type'].capitalize()}, Puissance: {move['power']}, Classe de dégâts: {move['damage_class']})\")\r\n    print(\"-\" * 50)\r\n\r\n\r\n\r\n# Fonction pour simuler un combat entre deux Pokémon\r\ndef simulate_battle(pokemon1, pokemon2):\r\n    # Extraire les stats des deux Pokémon\r\n    stats1 = pokemon1['stats']\r\n    stats2 = pokemon2['stats']\r\n\r\n    # Extraire les HP et la vitesse\r\n    hp1 = stats1.get('hp', 0)\r\n    speed1 = stats1.get('speed', 0)\r\n\r\n    hp2 = stats2.get('hp', 0)\r\n    speed2 = stats2.get('speed', 0)\r\n\r\n    # Déterminer quel Pokémon attaque en premier (celui avec le plus de vitesse)\r\n    if speed1 > speed2:\r\n        first, second = pokemon1, pokemon2\r\n        first_hp, second_hp = hp1, hp2\r\n    else:\r\n        first, second = pokemon2, pokemon1\r\n        first_hp, second_hp = hp2, hp1\r\n\r\n    print(f\"{first['name'].capitalize()} attaque en premier avec une vitesse de {speed1 if first == pokemon1 else speed2}.\")\r\n\r\n    # Combat en boucle jusqu'à ce que l'un des Pokémon ait 0 HP\r\n    while first_hp > 0 and second_hp > 0:\r\n        # Choisir aléatoirement un move pour le premier Pokémon\r\n        first_move = random.choice(first['moves'])\r\n        first_move_name = first_move['name']\r\n        first_move_power = first_move.get('power', 0)  # Utilisation de get pour éviter None\r\n\r\n        # Si la puissance est \"N/A\" ou None, on la remplace par 0\r\n        if first_move_power is None or first_move_power == \"N/A\":\r\n            first_move_power = 0\r\n\r\n        # Le premier Pokémon attaque le second\r\n        damage = first_move_power\r\n        second_hp -= damage\r\n        print(f\"{first['name'].capitalize()} utilise {first_move_name.capitalize()} et inflige {damage} points de dégâts à {second['name'].capitalize()}. HP restants de {second['name'].capitalize()}: {max(second_hp, 0)}\")\r\n\r\n        # Vérifier si le second Pokémon est KO\r\n        if second_hp <= 0:\r\n            print(f\"{second['name'].capitalize()} est KO !\")\r\n            return first\r\n\r\n        # Choisir aléatoirement un move pour le second Pokémon\r\n        second_move = random.choice(second['moves'])\r\n        second_move_name = second_move['name']\r\n        second_move_power = second_move.get('power', 0)  # Utilisation de get pour éviter None\r\n\r\n        # Si la puissance est \"N/A\" ou None, on la remplace par 0\r\n        if second_move_power is None or second_move_power == \"N/A\":\r\n            second_move_power = 0\r\n\r\n        # Le second Pokémon attaque le premier\r\n        damage = second_move_power\r\n        first_hp -= damage\r\n        print(f\"{second['name'].capitalize()} utilise {second_move_name.capitalize()} et inflige {damage} points de dégâts à {first['name'].capitalize()}. HP restants de {first['name'].capitalize()}: {max(first_hp, 0)}\")\r\n\r\n        # Vérifier si le premier Pokémon est KO\r\n        if first_hp <= 0:\r\n            print(f\"{first['name'].capitalize()} est KO !\")\r\n            return second\r\n\r\n    # Cette ligne ne sera jamais atteinte normalement, mais juste au cas où.\r\n    return None\r\n\r\n    winner = simulate_battle(pokemon1, pokemon2)\r\n    print(f\"\\nLe vainqueur est {winner['name'].capitalize()} !\")\r\n\r\n\r\n# Fonction pour organiser le tournoi\r\ndef run_tournament(pokemons):\r\n    round_number = 1\r\n    while len(pokemons) > 1:\r\n        print(f\"\\n--- Tour {round_number} ---\")\r\n        winners = []\r\n        # Itérer à travers les Pokémon par paires\r\n        for i in range(0, len(pokemons), 2):\r\n            # Vérifier si on a assez de Pokémon pour un combat\r\n            if i + 1 < len(pokemons):\r\n                pokemon1 = pokemons[i]\r\n                pokemon2 = pokemons[i + 1]\r\n                print(f\"{pokemon1['name'].capitalize()} vs {pokemon2['name'].capitalize()}\")\r\n                winner = simulate_battle(pokemon1, pokemon2)\r\n                print(f\"Vainqueur: {winner['name'].capitalize()}\\n\")\r\n                winners.append(winner)  # Ajouter le vainqueur à la liste des gagnants\r\n\r\n            else:\r\n                # Si un nombre impair de Pokémon, le dernier Pokémon passe automatiquement au tour suivant\r\n                print(f\"{pokemons[i]['name'].capitalize()} passe au tour suivant sans combat.\")\r\n                winners.append(pokemons[i])\r\n\r\n        # Mettre à jour les Pokémon pour le prochain tour\r\n        pokemons = winners\r\n        round_number += 1\r\n\r\n    # Afficher le vainqueur final\r\n    print(f\"Vainqueur du tournoi de la ligue Rubis : {pokemons[0]['name'].capitalize()}\")\r\n\r\n\r\n# Exemple d'utilisation pour exécuter le tournoi\r\ntype_effectiveness = get_type_effectiveness()\r\ndisplay_type_table(type_effectiveness)\r\nrun_tournament(unique_pokemons)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Poke.py b/Poke.py
--- a/Poke.py	(revision 87d1f016496aa6b7254aa3c0ac8de5d485d8a1a6)
+++ b/Poke.py	(date 1728309381219)
@@ -260,4 +260,3 @@
 
 
 
-
